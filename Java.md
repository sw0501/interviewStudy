# JAVA 예상 면접 질문

### JAVA 언어의 특징

- 객체 지향 프로그래밍 언어이다.
- int, char, float, double 등 기본 자료형을 제외한 모든 요소들이 객체로 표현
- 객체 지향의 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- ### 장점
  - JVM (Java Virtual Machine) 위에서 동작하기 때문에 운영체제에 독립적이다.
  - GC (Garbage Collection)을 통한 자동적인 메모리 관리가 가능하다.
- ### 단점
  - 다중 상속을 지원하지 않는다.
    - 다이아몬드 문제 발생
      > 조상 클래스를 각각 다르게 구현한 2개의 클래스를 다중 상속 받을 때 충돌이 생기는 문제
  - JVM 위에서 동작하기 때문에 실행속도가 C, C++ 언어에 비해서 상대적으로 느리다.

## JVM 역할

- 스택 기반으로 동작하며 JAVA Byte Code를 OS에 맞게 해석 해주는 역할
- 가비지 컬렉션을 통해 자동적인 메모리 관리를 해준다.

## JAVA 컴파일 과정?

-

## JAVA 제공 원시 타입

- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char
- 논리형 : boolean

## JAVA Collection

## 오버라이딩과 오버로딩의 차이

- ### 오버라이딩
  - 상위 클래스의 메소드를 하위 클래스에서 재정의 하는 것
- ### 오버로딩
  - 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것

## 객체 지향 프로그래밍 (OOP)

- 프로그램에 필요한 객체를 정의하고 객체들 간 상호작용을 통해 프로그램을 만드는 것
- 모듈 재사용을 통한 확장 및 유지 보수가 쉽다.
- 특징
  - ### 캡슐화
    - 접근제어자를 활용하여 클래스 내부의 변수나 메소드에 접근하는 것을 막는 것
    - 허가받지 않은 사용자로부터 데이터를 보호할 수 있다.
  - ### 상속
    - 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 방법
    - 상위 클래스의 속성과 기능들을 하위 클래스에서 간편하게 사용할 수 있도록 한다.
  - ### 다형성
    - 객체의 속성이나 기능이 여러 가지 형태를 가질 수 있는 성질
    - 오버로딩, 오버라이딩이 있음
  - ### 추상화
    - 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
    - JAVA에서는 추상 클래스와 인터페이스로 이를 활용함

## 추상 클래스와 인터페이스

- ### 추상 클래스
  > 클래스 내 추상 메소드가 하나 이상 포함되어있거나 abstract로 정의된 클래스
- ### 인터페이스
  > 모든 메소드가 추상 메소드로만 이루어져 있는 것
- ### 공통점
  - new 연산자로 인스턴스를 생성할 수 없다.
  - 사용하기 위해서는 하위 클래스에서 추상 메소드를 구현해야한다.
- ### 차이점
  - 인터페이스는 자신을 상속받는 클래스가 특정한 메소드를 반드시 구현하도록 강제한다.
  - 추상 클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고 기능 확장을 위해서 사용한다.
  - 추상 클래스는 다중 상속이 불가능하지만 인터페이스는 다중 상속이 가능하다
    - 이유 : 인터페이스의 경우 모든 메소드가 추상 메소드로 이루어져 있어 다이아몬드 문제가 발생하지 않는다.

## try-with-resources

- try-catch-finally의 문제점을 보완하는 개념
- try() 안에 자원 객체를 전달하면 try 블록이 끝나고 자동으로 지원을 해제하는 기능
- finally 구문이나 catch에 종료 구문을 작성할 필요가 없음

## 불변 객체

- 객체 생성 이후 내부의 상태가 변하지 않는 객체

## 디자인 패턴

## 싱글톤 패턴

- 단 하나의 인스턴스만을 사용하는 디자인 패턴
- 인스턴스가 1개만 존재한다는 것을 보장하며 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용
  - 메모리 낭비 방지
- 대표 예시는 Spring Bean으로 스프링 빈 등록 후 스프링 컨테이너에서 모든 빈들을 싱글톤으로 관리한다.
- ### 생성 방법
  - 클래스 내 private static 자기자신의 인스턴스 필드
  - private 생성자
  - public static 인스턴스 접근 메소드

## 가비지 컬렉션

- 동적으로 할당된 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리하는 기법
- 개발자가 컨트롤할 수 없음 (호출은 가능하지만 성능에 매우 안 좋은 영향을 끼치기 때문에 거의 사용하지 않음)
- 컬렉션 과정
  1. GC 작업 수행을 위해 JVM이 어플리케이션 실행을 잠시 멈춤
  2. GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단
  3. 사용하지 않는 메모리를 제거
  4. 작업 재개

## 객체지향의 설계 원칙 (SOLID)

- ### 단일 책임 원칙 (Single Responsibility principle)
  - 하나의 클래스는 하나의 책임만 가져야 한다. (비즈니스 로직 관점) `ex) 주문, 결제`
- ### 개방-폐쇄 원칙 (Open-Close principle)
  - 확장엔 열려있고 수정엔 닫혀있어야 한다.
  - 이를 적용하기 위한 주요 매커니즘으로 추상화와 다형성이 있다.
- ### 리스코프 치환 원칙 (Liskov substitution principle)
  - 하위 타입은 항상 상위 타입을 대체할 수 있어야 한다.
  - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 역할을 하는데 문제가 없어야 한다.
- ### 인터페이스 분리 원칙 (Interface segregation principle)
  - 인터페이스 내에 메소드는 최소한 일수록 좋다.
  - 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다 (SRP와는 다른 해결책)
- ### 의존관계 역전 원칙 (Dependency inversion principle)
  - 고수준 모듈이 저수준 모듈에 직접 의존하는 것을 피해야한다.
    - 고수준 모듈 : 변경이 없는 추상 클래스 or 인터페이스
    - 저수준 모듈 : 추상화된 클래스나 인터페이스를 상속받은 구현체 클래스
  - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라
  - DIP 원칙을 따르는 가장 인기있는 방법은 의존성 주입이다.

## 자바 메모리 영역

- 자바의 메모리 공간은 크게 Method 영역, Stack 영억, Headp 영역으로 구분되며 데이터 타입에 따라 할당
- ### 메소드 영역
  - 전역 변수와 static 변수를 저장
  - 프로그램 시작부터 종료까지 메모리에 남아있음
  - 할당되는 시점 : 클래스 로딩 시
- ### 스택 영역
  - 지역 변수와 매개 변수 데이터 값이 저장
  - 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리 해제
  - LIFO 구조를 가지고 변수에 새로운 데이터가 할당되면 이전 데이터는 삭제
  - 할당되는 시점 : 메소드 호출 시
- ### 힙 영역
  - new 키워드로 동적으로 생성되는 객체, 배열 등이 힙 영역에 저장
  - 가비지 컬렉션에 의해 메모리가 관리
  - 할당되는 시점 : 런타임시

## 클래스와 객체

- ### 클래스
  - 객체를 만들어내기 위한 설계도
- ### 객체
  - 객체는 일반적으로 존재하는 것을 추상화하여 속성과 기능으로 표현한 것
- 객체는 클래스를 통해 생성되며 메모리에 할당되어 실제로 활용되는 것을 인스턴스라고 부름

## 생성자

- 클래스와 같은 이름의 메소드로 객체가 생성될 시 호출되는 메소드
- 명시적으로 만들지 않으면 default로 만들어짐
- 매개변수를 다르게하여 오버로딩이 가능

## Wrapper Class, Boxing, Unboxing

- 기본 자료형에 대한 객체 표현을 Wrapper Class라고 함
- 기본 자료형을 Wrapper Class로 변환하는 것을 Boxing
- Wrapper Class에서 기본 자료형으로 변환하는 것 Unboxing

## Synchronized

## new String ()과 리터럴 ("")의 차이

- new String()은 new 키워드로 새로운 객체를 저장하기 때문에 Heap 메모리 영역에 저장됨
- ""는 Heap 안에 있는 String Constant Pool 영역에 저장
  - 리터럴로 같은 값을 참조하는 서로 다른 String 객체는 참조하는 주소값이 같기 때문에 객체 비교 시 true 반환
- 객체 참조, 복사, 값 수정 및 비교 시 위의 내용 때문에 원하는대로 동작하지 않을 수 있음

## 접근 제한자

- 변수 혹은 메소드의 접근 범위를 설정해주기 위해 사용하는 예약어
- 캡슐화와 관련 있음
- ### public
  - 접근 제한 없음
- ### protected
  - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능
- ### default
  - 해당 패키지 내에서만 접근 가능
- ### private
  - 해당 클래스에서만 접근 가능

## 클래스 멤버 변수 초기화 순서

1. static 선언부 : 클래스 로드 시 초기화
2. 필드 변수 선언부 : 객체 생성 시 생성자 block보다 먼저 초기화
3. 생성자 block : 객체 생성 시 초기화

## static 키워드

- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라가는 클래스 로드 시 자동으로 생성된다.
- 인스턴스 생성 없이 사용할 수 있음
- 프로그램이 종료될 때까지 메모리에 존재한다.
- ### 사용하는 이유
  - 자주 변하지 않는 값이나 공통으로 사용되는 공용 자원에 대한 접근 방법으로 주요 사용
  - 매번 객체 생성을 통해서 메모리에 로딩 시 낭비가 된다.
  - 싱글톤 패턴에서 사용

## Inner Class

- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성 낮춤
- 외부에서는 내부 클래스에 접근이 불가능하기 때문에 코드의 보안성을 높일 수 있음

## Error와 Exception

- ### Error
  - Error는 실행 중 일어날 수 있는 치명적인 오류
  - 컴파일 시점에 체크할 수 없고 오류가 발생하면 프로그램이 비정상 종료됨
- ### Exception
  - Error보다 경미한 오류이며 try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있음

## JAVA Collection

- 다수의 데이터를 효과적으로 관리할 수 있는 클래스의 집합
- List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재
